# **Лабораторная работа №2 "Классы и объекты. Использование конструкторов".**
>Вариант 11

Пользовательский класс АВТОМОБИЛЬ

Марка – string

Модель – string

Стоимость– int

# UML - диаграмма

![](https://psv4.userapi.com/c909328/u272768864/docs/d19/21686901a6f9/lab_2.png?extra=3hRFLJ3Hxve-9ubHBee0k9IpeGGDx78y2_oHGWD6f4OeE9mg7qxkn0ouCxAZnDDLNDlvSvgRwRiNz9yR4CCORt3UFlMEXYa50QwG3LNA10KZpr0MDJvOGSsPBjCKT8sLzzESrBwYJGTkElebVyu6j2_BaQ)

# **Код программы**
>main
```cpp
#include "Car.h" 
#include <iostream> 
#include <string> 
using namespace std;

//функция для возврата объекта как результата 
Car makeCar()
{
	string b;
	string m;
	int c;
	cout << "Enter brand: ";
	cin >> b;
	cout << "Enter model: ";
	cin >> m;
	cout << "Enter cost: ";
	cin >> c;
	Car t(b, m, c);
	return t;
}

//функция для передачи объекта как параметра 
void printCar(Car t)
{
	t.show();
}

void main()
{
	//конструктор без параметров 
	Car t1;
	t1.show();

	//коструктор с параметрами 
	Car t2("Lada ", "Vesta", 1500000);
	t2.show();

	//конструктор копирования 
	Car t3 = t2;
	t3.setBrand("Mersedes");
	t3.setModel("Benz");
	t3.setCost(5000000);

	//конструктор копирования 
	printCar(t3);

	//конструктор копирования 
	t1 = makeCar();
	t1.show();
}
```
>Car.cpp
```cpp
#include "Car.h" 
#include <iostream> 
#include <string> 
using namespace std;

//конструктор без параметров 
Car::Car()
{
	brand = "";
	model = "";
	cost = 0;
	cout << "Constructor without parameters " << this << endl;
}

//конструктор с параметрами 
Car::Car(string N, string K, int S)
{
	brand = N;
	model = K;
	cost = S;
	cout << "Constructor with parameters " << this << endl;
}

//конструктор копирования 
Car::Car(const Car& t)
{
	brand = t.brand;
	model = t.model;
	cost = t.cost;
	cout << "Copy constructor " << this << endl;
}

//деструктор 
Car::Car()
{
	cout << "Destructor " << this << endl;
}

//селекторы
string Car::getBrand()
{
	return brand;
}
string Car::getModel()
{
	return model;
}
int Car::getCost()
{
	return cost;
}

//модификаторы
void Car::setBrand(string N)
{
	brand = N;
}
void Car::setModel(string K)
{
	model = K;
}
void Car::setCost(int S)
{
	cost = S;
}

//метод для просмотра атрибутов 
void Car::show()
{
	cout << "Brand :" << brand << endl;
	cout << "Model :" << model << endl;
	cout << "Cost :" << cost << endl;
}
```
>Car.h
```cpp
#pragma once
#include <iostream> 
#include <string> 
using namespace std;

class Car {
	string brand;
	string model;
	int cost;
public:
	Car();//конструктор без параметров
	Car(string, string, int);//конструктор с параметрами 
	Car(const Car&);//конструктор копирования
	~Car();//деструктор

	string getBrand();//селектор
	void setBrand(string);//модификатор 

	string getModel();//селектор
	void setModel(string); //модификатор

	int getCost();//селектор
	void setCost(int); //модификатор 

	void show();//просмотр атрибутов
};
```
# **Контрольные вопросы**
>Для чего нужен конструктор?

Конструктор в языке С++ служит для создания объекта (выделения под него памяти, инициализации значений).

>Сколько типов конструкторов существует в С++?

В C++ существует 4 типа конструкторов:

- Default Constructor (Конструктор без параметров) — конструктор, который не принимает параметров.

- Parameterized Constructor (Конструктор с параметрами) — конструктор, который может принимать один или несколько аргументов.

- Copy Constructor (Конструктор копирования) — конструктор, который используется для создания копии уже существующего объекта класса.

- Dynamic Constructor (Динамический конструктор) — конструктор, который позволяет динамически инициализировать объекты.

>Для чего используется деструктор? В каких случаях деструктор описывается явно?

Деструктор используется для освобождения ресурсов, таких как память или файлы, при уничтожении объекта. Он обычно описывается явно, если класс управляет ресурсами, которые требуют особой очистки при уничтожении.
>Для чего используется конструктор без параметров? Конструктор с параметрами? 
Конструктор копирования?

- Конструктор без параметров используется для инициализации объекта с дефолтными значениями или значениями по умолчанию.
- Конструктор с параметрами используется для инициализации объекта с переданными значениями.
- Конструктор копирования используется для создания копии объекта существующего объекта того же типа.

>В каких случаях вызывается конструктор копирования?

Конструктор копирования вызывается при создании объекта как копии уже существующего объекта, при передаче объекта по значению в функцию или при возврате объекта из функции по значению.

>Перечислить свойства конструкторов.

- Конструктор не возвращает значение, даже типа void. Нельзя получить указатель на конструктор.

- Класс может иметь несколько конструкторов с разными параметрами для разных видов инициализации (при этом используется механизм перегрузки).

- Конструктор, вызываемый без параметров, называется конструктором по умолчанию.

- Параметры конструктора могут иметь любой тип, кроме этого же класса. Можно задавать значения параметров по умолчанию. Их может содержать только один из конструкторов.

- Если программист не указал ни одного конструктора, компилятор создает его автоматически.

- Конструкторы не наследуются.

>Перечислить свойства деструкторов.

- Класс может иметь только один деструктор.

- Деструктор имеет то же имя, что и класс, в котором он объявляется, с префиксом тильда (~).

- Деструктор не имеет параметров (аргументов).

- Деструктор не возвращает значения (даже типа void).

- Деструктор не наследуется в производных классах.

- Деструктор — это функция, и он может быть виртуальным (его можно объявить с ключевым словом virtual).

- В программе невозможно получить адрес деструктора (указатель на деструктор).

- Если деструктор не задан в программе, он будет автоматически сгенерирован компилятором для уничтожения соответствующих объектов.

- Деструктор можно вызвать так же, как обычную функцию, если использовать его полное имя.

- Деструктор вызывается автоматически только при разрушении (уничтожении) объекта.

>К каким атрибутам имеют доступ методы класса?

Методы класса имеют доступ ко всем членам класса, включая его публичные, защищенные и приватные атрибуты.

>Что представляет собой указатель this?

Указатель this - это указатель, который хранит адрес конкретного объекта класса.

>Какая разница между методами определенными внутри класса и вне класса?

Методы, определенные внутри класса, считаются методами-членами класса и имеют прямой доступ ко всем членам класса, включая приватные. Методы, определенные вне класса, являются методами-прототипами и требуют явного указания класса при их определении.

>Какое значение возвращает конструктор?

Конструктор не возвращает значение.

>Какие методы создаются по умолчанию?

В C++, если не определить явно, следующие методы создаются по умолчанию компилятором:
- Конструктор по умолчанию (без параметров)
- Конструктор копирования
- Оператор присваивания (assignment operator)
- Деструктор

>Какое значение возвращает деструктор?

Деструктор не возвращает значения.

>Дано описание класса 
class Student
{
string name; 
int group; 
public:
student(string, int); 
student(const student&)
~student();
};
Какой метод отсутствует в описании класса?

Отсутствует конструктор без параметров.

>Какой метод будет вызван при выполнении следующих операторов: 
student*s;
s=new student;

Конструктор без параметров.

>Какой метод будет вызван при выполнении следующих операторов: 
student s(“Ivanov”,20);

Конструктор с параметрами.

>Какие методы будут вызваны при выполнении следующих операторов: 
student s1(“Ivanov”,20);
student s2=s1;

Конструктор с параметрами, конструктор копирования.

>Какие методы будут вызваны при выполнении следующих операторов: 
student s1(“Ivanov”,20);
student s2; 
s2=s1;

Конструктор с параметрами, конструктор без параметров, конструктор копирования.

>Какой конструктор будет использоваться при передаче параметра в функцию print(): 
void print(student a)
{a.show();}

Конструктор копирования.

>Класс описан следующим образом:
class Student
{
string name; 
int age; 
public:
void set_name(string); 
void set_age(int );
…..
};
Student p;
Каким образом можно присвоить новое значение атрибуту name объекта р?

p.set_name("Новое имя");

